Optimizer
==
> mysql 기준으로 작성
---

- Mysql 내에는 Optimizer, Storage Engine 이 존재
  - Optimizer 는 데이터의 위치를 찾고 데이터를 찾을 가장 빠른 방법(쿼리 플랜)을 제시(Ex: 도서관의 사서)
  - Storage Engine(InnoDB) 은 데이터의 저장소로 쿼리 플랜에 따라 데이터를 읽어온다.
    - MySQL 여러 Storage Engine 사용이 가능하나 기본적으로 InnoDB 사용
---
## Optimizer 의 결정 방식
- 데이터 기반으로 쿼리 플랜을 결정
  - 인덱스의 크기, 테이블의 크기, 컬럼 통계 등..
- SQL 실행에 있어 데이터를 기반으로 최소한의 리소스를 이용해 최적의 성능을 제공하는 계획을 판단
- 적절치 않은 인덱스를 쌓거나 제공된 데이터가 부족하다면 원치 않는 쿼리 플랜이 실행 될 수 있다.
  - 쿼리 힌트를 통해 올바른 쿼리 플랜을 실행 하도록 해야함
---
## 쿼리 플랜 정보

- id: 여러 쿼리가 발생 시 쿼리의 순서 정보
- table: 처리한 테이블에 대한 정보
- type: 테이블의 데이터를 조회한 방식 (매우 중요)
- possible keys: 사용 가능한 인덱스 목록
- key: 데이터 조회 시 실제 사용한 인덱스
- ref: 테이블 조회 시 테이블 조인의 기준
- rows: sql 수행을 위해 테이블에 접근한 개수(높을 수록 시간 소요가 커짐)
- filtered: where 같은 필터 조건에 따라 어느 정도의 데이터를 제거했는지에 대한 정보, 높을 수록 필요한 정보만 가져온 것
---
## 쿼리 플랜 타입

- ALL
  - 전체 테이블을 처음부터 끝까지 스캔
  - 인덱스가 없을 시 발생, 가장 비효율적인 방식
- range
  - 특정 범위안의 데이터만 스캔
  - ALL 보다는 효울적
- ref
  - 인덱스를 통한 동등 빅교 시 발생
  - '=' 연산자 사용
  - 인덱스를 통해 특정 값을 바로 찾음, range 보다는 효율적
- const
  - pk 나 UNIQUE 인덱스로 하나의 행을 찾을 때 발생
  - 가장 빠른 조회 방식

```text
같은 쿼리여도 데이터가 적재된 형태에 따라 적합한 타입이 다르므로 쿼리플랜에서 항상 절대적인 것은 없음
즉, range 가 const 보다 좋을 경우가 존재
```