Lock의 방식과 종류
==
락이란 쉽게 말해서 먼저 사용한 사람이 사용을 끝낼때까지 다른 사람이 간섭을 하지 못하게 막는 것이다.

## Lock의 방식

Lock를 거는 방식에는 비관적 락, 낙관적 락이 존재한다.

예시를 위한 공통 상황: 공중 전화가 1대 존재하며, 전화 사용을 하고자 하는 사람이 약 30명 존재

### 비관적 락

비관적 락은 공중 전화 박스에 먼저 들어가면 무저건 문을 잠그고 사용한다와 같은 규칙이다.

- 트랜잭션 a가 공중 전화 박스에 먼저 들어감
- 락을 건다.(문을 잠근다.)
- 트랜잭션 a의 통화가 모두 끝나고 락을 해제해야 다음 사람이 사용 가능하다.

비관적 락의 사용 전제 조건: 많은 충돌이 예상되는 상황에서 사용

장점

- 데이터의 수정은 안전하게 막을 수 있다.(락을 먼저 선점한 트랜잭션만 데이터 수정을 보장)
  단점
- 선점한 락이 해제될 때까지 다른 트랜잭션들은 대기 상태로 들어간다.

### 낙관적 락

낙관적 락은 공중 전화 박스에 먼저 들어간 사람이 통화를 먼저 하지만 문을 잠그지는 않는다.

- 트랜잭션 a가 공중 전화 박스에 먼저 들어가서 락을 걸지 않는다.
- 트랜잭셔 b,c,d.. 등 역시 공중 전화 박스에 들어가고자 함
- 트랜잭션 a가 먼저 통화를 시도해 나머지 트랜잭션은 실패를 하고 재시도를 해야 함(먼저 커밋된 트랜잭션만 성공)

낙관적 락의 사용 전제 조건: 락을 걸지 않기에 충돌이 적은 상황에서 사용

장점

- 락을 걸지 않기에 충돌이 적다면 속도가 빠르다.
  단점
- 충돌이 발생하면 실패한 트랜잭션들을 다시 트랜잭션을 시도해야 한다.

| **사용 상황**                       | **비관적 락 (Pessimistic Lock)** | **낙관적 락 (Optimistic Lock)** |
|---------------------------------|------------------------------|-----------------------------|
| **충돌이 자주 발생하는 경우**              | ✅ 사용 (대기 시간이 길어질 가능성 있음)     | ❌ 충돌이 많으면 성능 저하             |
| **읽기 위주의 시스템 (조회가 많고, 수정이 적음)** | ❌ 불필요함                       | ✅ 사용 (조회수가 많은 경우)           |
| **다중 트랜잭션을 동시에 처리해야 하는 경우**     | ❌ 락 대기 시간이 길어질 수 있음          | ✅ 충돌이 적다면 성능 향상             |

## 락의 종류

- 테이블 락
- 베타 락(x-lock)
- 공유 락(s-lock)
- 갭 락
- 네임드 락

테이블 락

- 테이블 전체에 락을 거는 방식으로 락이 걸린 동안 다른 트랜잭션들은 UPDATE, DELETE, INSERT 연산을 수행할 수 없다.
- 동시성이 매우 낮아짐(=데이터 정합성이 높아)
- 테이블 백업(READ_LOCK), 데이터 마이그레이션(WRITE_LOCK) 상황에서 주로 사용

```java
LOCK TABLES
table_name READ;  --
읽기 전용

락(읽기는 가능해)

LOCK TABLES
table_name WRITE; --

쓰기 락(읽지도 마라)

UNLOCK TABLES;  --
락 해제
```

베타 락

- 한 트랙잭션이 데이터를 수정하는 동안 다른 트랜잭션들이 데이터 수정을 못하게 막음
- 베타 락이 걸린 레코드는 다른 트랜잭션이 x,s-lock 모두 획득할 수 없음, 레코드 수정(update,delete) 불가
- 락 없는 일반 SELECT 쿼리는 허용됨 (MySQL의 MVCC 특성 때문)
- 동시 수정 충돌 방지, 재고 차감 또는 포이튼 차감 등 값 기반 연산, 데이터를 읽은 후 바로 수 예정인 경우에 주로 사용

공유 락

- 공유 잠금이라고 불리며 여러 트랜잭션이 데이터를 조회하는 동안 데이터 수정을 못하도록 막는 락
- 여러 트랜잭션이 동시에 같은 데이터에 s-lock을 가지는 것이 가능 -> 여러 트랜잭션이 동시에 데이터를 읽을 수 있으나 수정은 불가
- 다른 트랜잭션과 같이 s-lock을 가지는게 가능한나 다른 트랜잭션들이 x-lock을 가지는것을 불가능
- 락이 없는 일반 select 쿼리는 가능
- 주로 읽은 데이터가 트랜잭션 중에 변경되지 않도록 보장해야 할 때, 보고서 생성이나 집계 작업 중 데이터 일관성이 필요할 때 사용

```text
- 1번 트랜잭션이 어떤 레코드 A에 대해 S락을 얻었다고 가정합니다.
- 2번 트랜잭션에서 레코드 A에 S락을 시도하면 성공합니다.왜냐하면 S락 끼리는 호환되기 때문입니다.
- 그러나 A레코드에 X락을 시도하면 대기상태에 빠집니다. (예를들어 UPDATE 쿼리)왜냐하면 이미 1번 트랜잭션이 S락을 가진 상태기 때문에 호환되지 않는 X락을 동시에 걸수가 없습니다.1번 트랜잭션이 종료되면 대기하던 2번 트랜잭션이 그제서야 X락을 획득하게 됩니다.
- 반대로 X락이 먼저 걸려있는 레코드에 S락을 시도하면, S락 시도도 대기상태에 빠집니다.
```

갭 락

- 레코드 자체가 아닌 레코드 사이의 공간에 락을 거는 방식
- where 조건에 맞는 데이터가 없어도 락이 걸 수 있으며, insert 방지용으로 사용

네임드 락

- 일반적인 데이터 락(테이블 락, 레코드 락)과는 다른 개념의 락
- 레코드가 아닌 특정 문자열(Key)에 락을 거는 방 -> MySQL 내부에서 "이름을 가진 임의의 리소스"에 대해 락을 설정하는 방식
- 특정한 작업을 동기화하거나, 분산 환경에서 동시 실행을 방지 가능
- 네임드 락 사용으로 특정 유저 또는 특정 행동에 락을 걸 수 있 -> 주문이 완료되거나 롤백될 때까지, 같은 주문에 대한 추가 요청이 실행되지 않도록 보호하기 위함
- 해당 방식은 Mysql 부하(Pool의 고갈 문제)를 초래하므로 Redis를 이용한 분산락을 좀 더 선호한다.

```text
유저당 이벤트는 최대 3개까지만 참여 가능하다 라는 조건이 있다고 해보겠습니다.

이 문제는 MySQL의 일반적인 행 락(Row Lock)이나 테이블 락(Table Lock)으로 해결하기 어렵습니다.

왜냐하면, 새로운 콘서트 참가 신청(INSERT)이 발생할 때, "기존 데이터 개수"를 먼저 확인해야 하기 때문입니다.

즉, `INSERT` 문 자체에 락을 걸 수 없으므로, "참여 가능 여부를 확인하는 과정" 전체를 보호해야 합니다. user 1이 이벤트 참여하는 행위 자체를 “user_1_event” 라는 이름으로 락을 설정합니다.

이럴 때, 네임드 락(Named Lock)을 사용하여 특정 유저의 "참여 검증 및 삽입 과정"을 동기화할 수 있습니다.
```