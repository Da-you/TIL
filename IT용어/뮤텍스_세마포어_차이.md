뮤텍스와 세마포어 차이
==
## Mutex(뮤텍스)

- 자원에 대한 접근을 동기화하기 위해 사용되는 상호배제 기술
- 프로그램 시작 시 고유한 이름으로 생성
- 락 메커니즘으로 오직 하나의 스레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역에 접근 가능
    - 해당 스레드만이 임계 영역에서 나갈 때 뮤텍스 해제가 가능
    - 1개의 락만을 가지는 메커니즘

> 임계영역이란?
> 
> 여러 개의 스레드가 동시에 접근하면 문제가 발생할 수 있는 공유 자원을 사용하는 코드 영역을 의미

동작 과정
```shell
wait (mutex);
…..
Critical Section
…..
signal (mutex);
```
---
## Semaphore(세마포어)

- Signaling 메커니즘이라는 점이 뮤텍스와 다름
- 락을 걸지 않은 스레드도 Signal을 보내 락 해제 가능
- wait, signal 이라는 2개의 원자적 연산을 사용
  - wait 호출 시 세마포어의 카운트를 1 감소, signal 호출 시 카운트 1 증가
  - 세마포어의 카운트가 0보다 작거나 같아질 경우 락 실행
- 바이너리 세마포어, 카운팅 세마포어가 존재
  - 바이너리 : 세마포어는 카운트가 1이며 뮤텍스처럼 사용 가능(뮤텍스는 세마포어처럼 사용 불가)
  - 카운팅 세마포어 : 내부에 정수 값을 유지해, 해당 개수 이상의 스레드가 자원에 접근하지 못하도록 제한하는 동기화 기법 

동작 과정
```declarative
struct semaphore {
    int count;
    queueType queue;
};

void semWait (semaphore s) {
    s.count--;
    if (s.count <= 0) {
    	// 락이 걸리고 공유 자원에 접근할 수 없음
    }
} 

void semSignal (semaphore s) {
    s.count++;
    if (s.count <= 0) {
    	// 아직 락에 걸려 대기중인 프로세스가 있음
    }
}
```
---
## 차이점

- 뮤텍스는 락 메커니즘으로 락을 건 스레드만이 임계영역에서 나갈때 락 해제 가능
- 세마포어는 signaling 메커니즘으로 락을 걸지 않은 스레드에서도 signal을 사용해 락 해제 가능

---
## 출처
https://mangkyu.tistory.com/104